Харківський національний університет радіоелектроніки
Факультет комп'ютерних наук
Катедра програмної інженерії
    
    
    
    
    
    
ЗВІТ
з практичного заняття №1
з дисципліни  «Аналіз та рефакторинг коду»
на тему: «Правила оформлення програмного коду»
    
    
    
    
    
    
    Виконав
    ст. гр. ПЗПІ-22-3
    Шпак Денис Олександрович

    Перевірив
    ст. викладач катедри ПІ
    Сокорчук Ігор Петрович
    
    

    
Харків 2024
1 МЕТА РОБОТИ

     Ознайомитися з основними рекомендаціями щодо написання чистого, ефективного та підтримуваного коду для різних мов програмування, а також навчити аналізувати та рефакторити код для покращення його якості.
    
2 ВСТУП

     При написанні коду дуже важливо, щоб він був читабельним та масштабуємим. Це забезпечує зручність роботи з кодом не лише для автора, але й для інших розробників, які зможуть швидко розібратися в логіці і функціоналі програми, а також легко доповнювати або змінювати її без ризику внести помилки.
     Код, написаний з урахуванням принципів чистоти, є ефективним та легким для тестування, підтримки й масштабування. Такий підхід сприяє спрощенню процесів рефакторингу та полегшує майбутнє розширення функціональності.
     Ця робота спрямована на ознайомлення з ключовими рекомендаціями щодо написання чистого та підтримуваного коду для різних мов програмування, а також на формування навичок аналізу й рефакторингу коду для підвищення його якості.
    
3 ХІД РОБОТИ

     Посилання на відео з демонстраціями порад оформлення коду мовою Go наведено у додатку А.
     Порада: використовуйте програму gofmt.
     Інструмент gofmt в Go забезпечує єдиний стиль форматування коду для всіх розробників, що сприяє стандартизації та підвищує читабельність [1]. Він автоматично виправляє відступи, пробіли та інші елементи оформлення, завдяки чому код виглядає однаково незалежно від уподобань програміста. Це зменшує кількість обговорень щодо стилю і допомагає фокусуватися на логіці програми.
     Недотримання рекомендацій може ускладнити читання і підтримку коду іншими програмістами. Відсутність єдиного формату може призвести до плутанини, збільшити час на перевірку та зменшити продуктивність команди. Форматування за допомогою gofmt полегшує внесення змін та робить код зрозумілим у майбутньому.
     Приклади гарного та поганого форматувань наведено у додатку Б.
     Порада: не слід використовувати коментарі у очевидних місцях. Треба писати інтуітивно зрозумілий код. Проте коментарями можна додати більшої ясності коду.
     Правило щодо уникнення коментарів в очевидних місцях важливе, так як в Go, надається перевага написанню інтуїтивно зрозумілого коду. Код має бути самодокументованим, використовуючи зрозумілі назви змінних, функцій та структур.
     Недотримання цього правила може призвести до того, що код стане перевантаженим непотрібними коментарями, що ускладнить його сприйняття та збільшить час на підтримку.
     Приклади поганого та гарного коментуваньи коду наведено у додатку В.
     Порада: обирайте лаконічні й зрозумілі назви для функцій, змінних та пакетів.
     Чистота та однозначність у назвах допомагають розробникам швидше зрозуміти код. Чіткі назви сприяють тому, що код стає самодокументованим і легким для читання без необхідності додаткових пояснень.
     Якщо не дотримуватися цього правила, код може стати заплутаним і важким для сприйняття. Незрозумілі назви ускладнюють його підтримку, знижують продуктивність команди та збільшують час на розбір та внесення змін у проєкт. 
     Приклади поганого та гарного найменувань наведено у додатку Г.
     Порада: використовуйте множинне повернення з функцій. Повертайте помилку поруч з основними даними та використовуйте ключове слово defer для відкладеного виклику функцій.
     Використання множинного повернення з функцій у Go, особливо з передачею помилки разом з основними даними, є слушною практикою через особливості управління помилками в мові [1]. 
     Використання слова defer сприяє покращенню читабельності коду.
     Якщо не дотримуватися цих рекомендації, помилки можуть бути пропущені або неправильно оброблені, що призведе до складності в налагодженні та підтримці коду. Код стане менш читабельним.
     Приклади гарного та поганого написання функцій наведено у додатку Д.
     Порада: обробляйте помилки після кожного виклику функцій. Додавайте префікси до помилок.
     Потрібно явно перевіряти помилки для кожної функції, що повертає їх, і приймати відповідні рішення в разі їх виникнення. Додавання префіксів до помилок також допомагає зрозуміти, в якій частині коду сталася помилка, і спростити відстеження проблем.
     Недотримання цього правила може призвести до того, що помилки залишаться непоміченими, що, в свою чергу, може викликати серйозні проблеми в роботі програми.
     Приклади гарної та поганої обробок помилок наведено у додатку Е.
     Порада: викликайте паніку, щоб програма не продовжувалась без можливості виконувати функціонал.
     Виклик паніки використовується для критичних помилок, які не можуть бути оброблені звичайним чином, таких як неналежні дані або непередбачувані умови. Це дозволяє уникнути некоректної поведінки програми, зменшуючи ризик ушкодження даних або потрапляння в некоректні стани.
     Недотримання цього правила може призвести до ситуацій, коли програма продовжує виконуватись, незважаючи на критичні помилки, що може викликати серйозні проблеми, такі як неправильні результати, збільшення витрат часу на виявлення помилок або навіть крах системи.
     Приклади гарного та поганого підходу до використання паніки наведено у додатку Ж.
     Порада: передавайте контексти до функцій.
     Використання контекстів забезпечує більш ефективне управління ресурсами та дозволяє уникнути блокувань, що може виникнути при виконанні тривалих операцій.
     Недотримання цього правила може призвести до проблем з управлінням запитами, наприклад, коли функції продовжують виконуватись навіть після завершення основного запиту.
     Приклади поганого та гарного використань об’єкту context наведено у додатку И.
     Слайди презентації, що ілюструють результати виконання даної практичної роботи наведено у додатку К.
ВИСНОВКИ

     Було ретельно ознайомлено з основними принципами, рекомендаціями та кращими практиками щодо написання чистого, ефективного, продуктивного, оптимізованого, легко підтримуваного коду для мови програмування Go.
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ

   1. Effective GO. Go.Dev. URL: https://go.dev/doc/effective_go (дата використання: 8.10.2024).

























ДОДАТОК А
Відео-посилання на YouTube

     https://www.youtube.com/watch?v=3MclRI8UAok

























ДОДАТОК Б
Приклади поганого та гарного форматувань

01 // Поганий приклад
02 func PostHandler( w  http.ResponseWriter ,  r  * http.Request)  {
03      defer r .Body.Close()
04        postId ,_:=primitive.ObjectIDFromHex(id)
05
06  render.JSON(w,r, map[string]interface{}{
07      "Status" : http.StatusOK,
08        "Message" :"Successfully deleted" } ) }
09 // Гарний приклад
10 func PostHandler(w http.ResponseWriter, r *http.Request) {
11      defer r.Body.Close()
12
13      id := chi.URLParam(r, "id")
14
15      postId, _ := primitive.ObjectIDFromHex(id)
16
17      render.JSON(w, r, map[string]interface{}{
18              "Status":  http.StatusOK,
19              "Message": "Successfully deleted",
20      })
21 }











ДОДАТОК В
Приклади поганого та гарного коментування

01 // Поганий приклад
02 // Фунція приймає w та r
03 func phandl(w http.ResponseWriter, r *http.Request) {
04      // Відкладення закриття тіла запиту
05      defer r.Body.Close()
06
07      // Отримання айді з юрл
08      id := chi.URLParam(r, "id")
09
10      // Перетворення айді на много об'єкт
11      pId, _ := primitive.ObjectIDFromHex(id)
12
13      // Виклик функції Delete
14      _ = postRemover.Delete(
15              context.TODO(),
16              postId,
17      )
18      // Запис відповіді в форматі JSON
19      render.JSON(w, r, map[string]interface{}{
20              "Status":  http.StatusOK,
21              "Message": "done",
22      })
23 }
24 // Гарний приклад
25 // PostHandler - це обробник події видалення поста.
26 // Він викликає функцію Delete інтерфейсу PostRemover
27 func PostHandler(w http.ResponseWriter, r *http.Request) {
28      defer r.Body.Close()
29
30      id := chi.URLParam(r, "id")
31
32      postId, _ := primitive.ObjectIDFromHex(id)
33      _ = postRemover.Delete(
34              context.TODO(),
35              postId,
36      )
37
38      render.JSON(w, r, map[string]interface{}{
39              "Status":  http.StatusOK,
40              "Message": "Successfully deleted",
41      })
42 }



























ДОДАТОК Г
Приклади поганого та гарного найменувань

01 // Поганий приклад
02 package mongodbwithsavingseature
03
04 type storage struct {
05      Db *mongo.Client
06 }
07
08 func new_storage(storagePath string) *storage {
09      db, _ := mongo.Connect(
10              options.Client().ApplyURI(storagePath),
11      )
12
13      return storage{Db: db}
14 }
15 // Гарний приклад
16 package mongodb
17
18 type Storage struct {
19      db *mongo.Client
20 }
21
22 func New(storagePath string) *Storage {
23      db, _ := mongo.Connect(
24              options.Client().ApplyURI(storagePath),
25      )
26
27      return Storage{db: db}
28 }


ДОДАТОК Д
Приклади поганого та гарного написання функцій

01 // Поганий приклад
02 func New(log *slog.Logger, postRemover PostRemover) http.HandlerFunc {
03      func(w http.ResponseWriter, r *http.Request) {
04              id := chi.URLParam(r, "id")
05
06              postId, _ := primitive.ObjectIDFromHex(id)
07
08              render.JSON(w, r, map[string]interface{}{
09                      "Status":  http.StatusOK,
10                      "Message": "Successfully deleted",
11              })
12      }
13 }
14 // Гарний приклад
15 func New(log *slog.Logger, postRemover PostRemover) (http.HandlerFunc, error) {
16      func(w http.ResponseWriter, r *http.Request) {
17              defer r.Body.Close()
18
19              id := chi.URLParam(r, "id")
20
21              postId, _ := primitive.ObjectIDFromHex(id)
22
23              render.JSON(w, r, map[string]interface{}{
24                      "Status":  http.StatusOK,
25                      "Message": "Successfully deleted",
26              })
27      }, nil
28 }
ДОДАТОК Е
Приклади поганої та гарної обробок помилок

01 // Поганий приклад
02 func New(storagePath string) (*Storage, error) {
03      db, _ := mongo.Connect(
04              options.Client().ApplyURI(storagePath),
05      )
06
07      return &Storage{db: db}, nil
08 }
09 // Гарний приклад
10 func New(storagePath string) (*Storage, error) {
11      const op = "storage.mongodb.New"
12
13      db, err := mongo.Connect(
14              context.Background(),
15              options.Client().ApplyURI(storagePath),
16      )
17
18      if err != nil {
19              return nil, fmt.Errorf("%s: %w", op, err)
20      }
21
22      return &Storage{db: db}, nil
23 }









ДОДАТОК Ж
Приклади поганого та гарного підходу до використання паніки

01 // Поганий приклад
02 func New(storagePath string,
03      httpPort int,
04      timeout time.Duration) *App {
05      storage, err := mongodb.New(storagePath)
06      if err != nil {
07              fmt.Println("DB not started")
08      }
09
10      httpApp := httpapp.New(
11              storage, storage, storage,
12              httpPort, timeout,
13      )
14
15      return &App{
16              HttpServer: httpApp,
17      }
18 }
19 // Гарний приклад
20 func New(storagePath string,
21      httpPort int,
22      timeout time.Duration) *App {
23      storage, err := mongodb.New(storagePath)
24      if err != nil {
25              panic(err)
26      }
27
28      httpApp := httpapp.New(
29              storage, storage, storage,
30              httpPort, timeout,
31      )
32
33      return &App{
34              HttpServer: httpApp,
35      }
36 }








ДОДАТОК И
Приклади поганого та гарного використань контексту

01 // Поганий приклад
02 func (s *Storage) GetPostById(
03      postId primitive.ObjectID,
04 ) (*models.Post, error) {
05      collection := s.db.Database("DevHubDB").Collection("posts")
06
07      post := &models.Post{}
08      filter := bson.M{"_id": postId}
09
10      _ = collection.FindOne(context.TODO(), filter).Decode(post)
11
12      return post, nil
13 }
14 // Гарний приклад
15 func (s *Storage) GetPostById(
16      ctx context.Context,
17      postId primitive.ObjectID,
18 ) (*models.Post, error) {
19      collection := s.db.Database("DevHubDB").Collection("posts")
20
21      post := &models.Post{}
22      filter := bson.M{"_id": postId}
23
24      _ = collection.FindOne(ctx, filter).Decode(post)
25
26      return post, nil
27 }













ДОДАТОК К
Скриншоти презентації

 
Рисунок К.1 – Титульний лист

 
Рисунок К.2 – Порада, щодо форматування


Рисунок К.3 – Пояснення, щодо правил форматування в Go


Рисунок К.4 – Приклад невідформатованого коду і відформатованого


Рисунок К.5 – Рекомендації, щодо написання коментарів


Рисунок К.6 – Приклад поганого та нормального коментування

 
Рисунок К.7 – Рекомендації, щодо найменування в Go

 
Рисунок К.8 – Друга частина реакомендацій, щодо найменування в Go
 
Рисунок К.9 – Приклад коду з поганим найменуванням та з гарним

 
Рисунок К.10 – Рекомендації, щодо використання функцій
 
Рисунок К.11 – Друга частина рекомендацій, щодо використання функцій

 
Рисунок К.12 – Приклад поганого використання функцій та гарного
 
Рисунок К.13 – Рекомендації, щодо обробки помилок

 
Рисунок К.14 – Приклад поганої та гарної обробки помилок
 
Рисунок К.15 – Рекомендації, щодо виклику паніки

 
Рисунок К.16 – Приклад коду без паніки та з нею
 
Рисунок К.17 – Рекомендації, щодо використання контексту

 
Рисунок К.18 – Приклад коду без контексту та з ним

Рисунок К.19 – Список використаних джерел

    
    
