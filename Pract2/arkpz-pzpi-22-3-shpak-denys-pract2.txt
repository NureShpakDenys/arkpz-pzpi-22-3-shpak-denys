Харківський національний університет радіоелектроніки
Факультет комп'ютерних наук
Катедра програмної інженерії
    
    
    
    
    
    
ЗВІТ
з практичного заняття №2
з дисципліни  «Аналіз та рефакторинг коду»
на тему: «Методи рефакторингу коду програмного забезпечення»
    
    
    
    
    
    
    Виконав
    ст. гр. ПЗПІ-22-3
    Шпак Денис Олександрович

    Перевірив
    ст. викладач катедри ПІ
    Сокорчук Ігор Петрович
    
    

    
Харків 2024
1 МЕТА РОБОТИ

     Навчитися основним методам рефакторингу коду на основі реальних прикладів з власних програмних проєктів. Маємо навчитися ідентифікувати проблеми в коді та використовувати відповідні методи рефакторингу для покращення його якості.
     
2 ВСТУП

     Рефакторинг — це процес внесення змін до внутрішньої структури коду без зміни його зовнішньої поведінки. Основна мета рефакторингу полягає в покращенні якості коду, його читабельності, підтримуваності та зрозумілості без зміни функціональності програми. Іншими словами, рефакторинг дозволяє зробити код більш зрозумілим та простішим у супроводі, зберігаючи при цьому всі його вихідні функціональні можливості.
    Дана робота спрямована на ознайомлення з ключовими методами рефакторингу кода. Розуміння доцільності використання певного методу рефакторингу допоможе писати чистий, зрозумілий та легкопідтримуємий код. 
    
3 ХІД РОБОТИ

     Посилання на відео з поясненням методів рефакторинга код наведено у додатку А.
     
     3.1 Перший метод
     
     Код, до якого буде застасовано перший метод рефакторинга, наведено у додатку Б на рядках 2-47.
     
     
     3.1.1 Опис коду до рефакторинга
     
     Метод AddEmotionalAnalysis, наведений у додатку Б на рядках 2-17 відповідає за додавання нового запису до бази даних для збереження аналізу емоційного стану користувача. Спочатку цей метод створює контекст з тайм-аутом у 5 секунд за допомогою виклику методу createContextWithTimeout. Далі, він намагається виконати SQL-запит на вставку запису в таблицю emotionalanalysis, використовуючи метод executeInsertQuery. Якщо під час виконання запиту виникає помилка, викликається метод handleInsertError для її обробки. У разі успішного виконання запиту метод отримує ID останнього вставленого запису через метод getLastInsertID. Якщо виникає помилка при отриманні ID, її обробляє метод handleIDError. Останнім кроком є перетворення ID з типу int64 в тип int за допомогою методу convertIDToInt, що дозволяє повернути значення ID як результат роботи основного методу.
     
     3.1.2 Опис причин необхідності застосування рефакторинга
     
     Основною проблемою даного коду є занадто велике винесення функцій в окремі методи. Окремі методи, такі як createContextWithTimeout, executeInsertQuery, handleInsertError, getLastInsertID, handleIDError і convertIDToInt, виконують досить прості завдання, що можуть бути виконані безпосередньо в основному методі.
     Оскільки код виконує базові операції, такі як створення контексту, виконання запиту та обробка помилок, немає необхідності для кожного з цих кроків створювати окремі методи. В результаті цього виникає підвищена складність, оскільки методи з одним або двома рядками додають складності для розуміння структури коду, а також знижують його читаємость і продуктивність.
     
     
     
     3.1.3 Обгрунтування вибору метода рефакторинга
     
     Щоб усунути проблему, описану вище, можна використати метод рефакторингу "Вбудовування методу". Цей метод полягає у тому, щоб замінити виклики малих методів безпосередньо їх кодом у місці виклику. Замість того, щоб викликати метод для створення контексту, можна просто створити контекст безпосередньо в основному методі AddEmotionalAnalysis. Аналогічно, замість виклику методів для виконання запиту, обробки помилок і перетворення ID можна реалізувати ці операції прямо в основному методі.
     
     3.1.4 Аналіз коду після застосування методу рефакторинга
     
     Код після застосування методу «Вбудовування методу» наведено у додатку Б на рядках 50-70.
     Після застосування методу рефакторингу вбудовування методу код значно покращився в плані простоти та читабельності. Видалення окремих методів, що виконували прості операції, дозволило зробити основний метод AddEmotionalAnalysis більш лаконічним та зрозумілим. Тепер всі операції, які раніше виконувалися через виклики окремих, виконуються безпосередньо в тілі основного методу. Це дозволяє зробити код більш зрозумілим, оскільки всі необхідні дії тепер розташовані в одному місці, що спрощує процес читання та підтримки коду. Зменшення кількості методів також підвищує ефективність виконання, оскільки зменшується накладні витрати на виклики функцій. У результаті, код став компактнішим, без зайвих проміжних кроків, що дозволяє зосередитися на основній бізнес-логіці.
     
     3.2 Другий метод
     
     Код, до якого буде застосовано другий метод рефакторингу, наведено у додатку В на рядках 2-42.
     3.2.1 Опис коду до рефакторингу
     
     Метод Save, наведений у додатку В на рядках 11-42, відповідає за збереження нового поста в базі даних. Він приймає кілька параметрів, які передаються безпосередньо в метод, після чого ці дані використовуються для створення нового об'єкта Post і вставки його в колекцію "posts" в базі даних MongoDB. У разі успіху метод повертає ID вставленого поста. Якщо виникає помилка, вона обробляється і повертається відповідна помилка.
     
     3.2.2 Опис причин необхідності застосування рефакторингу
     
     Основною проблемою даного коду є використання численних параметрів при викликові методу Save на рядках 2-10, що ускладнює його використання і тестування. Кілька параметрів, переданих безпосередньо в метод, можуть зробити код менш зрозумілим і схильним до помилок при зміні або додаванні нових параметрів. Якщо зміниться структура даних або потрібно буде передавати додаткові параметри, метод стане менш гнучким і більш схильним до помилок. Крім того, велика кількість параметрів у сигнатурі методу ускладнює його розширення та підтримку в майбутньому.
     
     3.2.3 Обґрунтування вибору методу рефакторингу
     
     Щоб усунути проблему, описану вище, доцільно застосувати метод рефакторингу "Запровадження об'єкта параметра". Цей метод полягає у створенні окремої структури, що інкапсулює всі параметри, які передаються в метод. Створення такого об'єкта зменшує кількість параметрів у сигнатурі методу і робить код більш гнучким та легким для підтримки. Замість того, щоб передавати кожен параметр окремо, ми передаємо один об'єкт, що містить усі необхідні дані.
     
     3.2.4 Аналіз коду після застосування методу рефакторингу
     
     Код після застосування методу рефакторингу "Запровадження об'єкта параметра" наведено у додатку В на рядках 45-80.
     Після рефакторингу замість численних параметрів в метод Save передається один об'єкт PostData, який містить усі необхідні поля. Це дозволяє зменшити кількість параметрів у сигнатурі методу та зробити його більш читабельним і зручним для роботи. Такий підхід спрощує додавання нових полів у майбутньому: достатньо буде лише оновити структуру PostData, не змінюючи кожного виклику методу. Окрім того, це дозволяє зменшити ймовірність помилок при викликах методу, оскільки зменшується кількість параметрів, які потрібно передавати.
     Загалом, код став більш організованим і більш готовим до розширення в майбутньому, а також його легше тестувати та підтримувати.
     
     3.3 Третій метод
     
     Код, до якого буде застосовано третій метод рефакторингу, наведено у додатку Г на рядках 2-7.
     
     3.3.1 Опис коду до рефакторингу
     
     Метод, наведений у додатку Г на рядках 2-7, здійснює перевірку наявності значень у декількох полях форми запиту. Спочатку перевіряється, чи порожні поля "title", "content" і "tags". Якщо ці поля не містять даних, додатково перевіряється, чи відсутнє зображення у полі "headerImage". Якщо зображення відсутнє, викликається метод HandleError, який обробляє помилку, повертаючи клієнту статус "400 Bad Request" і повідомлення, що хоча б одне поле повинно бути заповнене. Якщо жодне з полів не заповнене, метод припиняє виконання.
     
     3.3.2 Опис причин необхідності застосування рефакторингу
     
     Основною проблемою даного коду є занадто велика складність умовного оператора. Перевірка кількох умов у одному виразі робить код важким для розуміння та модифікації. Витягування таких умов у окремі функції допоможе підвищити читабельність та спростити супровід коду. Крім того, код містить дублювання логіки перевірки, яке можна звести до мінімуму, застосувавши рефакторинг, що дозволить легше змінювати умови перевірки, не порушуючи основної логіки.
     
     3.3.3 Обґрунтування вибору методу рефакторингу
     
     Щоб усунути проблему, описану вище, доцільно застосувати метод рефакторингу "Розкладання умовного оператора". Цей метод передбачає перенесення частини умовних перевірок у окремі функції, що значно підвищує читабельність і зрозумілість коду. Кожна функція тепер перевірятиме одну умову, що робить код більш лінійним і зрозумілим. У результаті рефакторингу, умови перевірки перетворюються на функції, що дозволяє зберегти основну логіку перевірки, але робить її більш організованою і менш заплутаною.
     
     3.3.4 Аналіз коду після застосування методу рефакторингу
     
     Код після застосування методу рефакторингу "Розкладання умовного оператора" наведено у додатку Г на рядках 10-25. Після рефакторингу, умовний оператор значно спрощується. Перевірка полів "title", "content" і "tags", а також перевірка наявності зображення у полі "headerImage" тепер виконуються через виклики окремих функцій: isTitleContentAndTagsEmpty і isHeaderImageMissing. Ці функції виконують конкретні перевірки, що значно спрощує основний код і робить його набагато зрозумілішим.
     Замість того, щоб цьому коду бути об'єднаним в одну складну умову, кожна перевірка тепер знаходиться в окремій функції, що дозволяє розділити відповідальність і знизити складність. Це полегшує підтримку коду, оскільки кожну перевірку можна змінювати або доповнювати окремо. Крім того, функції можна використовувати повторно в інших місцях коду, що підвищує їхню універсальність.
     Загалом, код став більш структурованим, що покращує його читабельність, а також робить його легшим для тестування та модифікації в майбутньому.
     Слайди презентації, що ілюструють результати виконання даної практичної роботи наведено у додатку Д.
     
ВИСНОВКИ

     Навчилися основним методам рефакторингу коду на основі реальних прикладів з власних програмних проєктів. Було отримано навички з  ідентифікування проблем в коді та використання відповідних методів рефакторингу для покращення його якості.
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ

   1. Мартін Ф. (2018). Refactoring: Improving the Design of Existing Code. (дата використання: 15.11.2024).

























ДОДАТОК А
Відео-посилання на YouTube

https://youtu.be/ktWTOykq_kI
























ДОДАТОК Б
Код до та після застосування методу «Вбудовування методу»

01 // До рефакторингу
02 func (s *service) AddEmotionalAnalysis(emotionalAnalysis models.EmotionalAnalysis) (int, error) {
03      ctx, cancel := s.createContextWithTimeout(5 * time.Second)
04      defer cancel()
05
06      result, err := s.executeInsertQuery(ctx, emotionalAnalysis)
07      if err != nil {
08              return s.handleInsertError(err)
09      }
10
11      id, err := s.getLastInsertID(result)
12      if err != nil {
13              return s.handleIDError()
14      }
15
16      return s.convertIDToInt(id)
17 }
18
19 func (s *service) createContextWithTimeout(duration  time.Duration) (context.Context, context.CancelFunc) {
20      return context.WithTimeout(context.Background(), duration)
21 }
22
23 func (s *service) executeInsertQuery(ctx context.Context, emotionalAnalysis models.EmotionalAnalysis) (sql.Result, error) {
24      query := `INSERT INTO emotionalanalysis (emotionalstate, emotionalIcon) VALUES (?, ?)`
25      return s.db.ExecContext(ctx, query, emotionalAnalysis.EmotionalState, emotionalAnalysis.EmotionalIcon)
26 }
27
28 func (s *service) handleInsertError(err error) (int, error) {
29      log.Printf("Error executing insert query: %v", err)
30      return 0, fmt.Errorf("failed to execute insert query: %w", err)
31 }
32
33 func (s *service) getLastInsertID(result sql.Result) (int64, error) {
34      id, err := result.LastInsertId()
35      if err != nil {
36              return 0, fmt.Errorf("failed to get last insert ID: %w", err)
37      }
38      return id, nil
39 }
40
41 func (s *service) handleIDError() (int, error) {
42      return 0, fmt.Errorf("error retrieving ID")
43 }
44
45 func (s *service) convertIDToInt(id int64) (int, error) {
46      return int(id), nil
47 }
48
49 // Після рефакторингу
50 func (s *service) AddEmotionalAnalysis(emotionalAnalysis models.EmotionalAnalysis) (int, error) {
51      query := `INSERT INTO emotionalanalysis (emotionalstate, emotionalIcon) VALUES (?, ?)`
52      ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
53      defer cancel()
54
55      result, err := s.db.ExecContext(
56              ctx,
57              query,
58              emotionalAnalysis.EmotionalState,
59              emotionalAnalysis.EmotionalIcon,
60      )
61      if err != nil {
62              return 0, err
63      }
64      id, err := result.LastInsertId()
65      if err != nil {
66              return 0, nil
67      }
68
69      return int(id), nil
70 }





ДОДАТОК В
Код до та після застосування методу «Запровадження об’єкту параметра»

01 // До рефакторингу
02 id, err := storage.Save(
03      context.Background(),
04      primitive.NewObjectID(),
05      "My Post Title",
06     "Post content goes here...",
07      "header_image_url",
08      []string{"tag1", "tag2"}
09 )
10
11 func (s *Storage) Save(
12      ctx context.Context,
13      userId primitive.ObjectID,
14      title string,
15      content string,
16      headerImage string,
17      tags []string)
18 (primitive.ObjectID, error) {
19      const op = "storage.mongodb.Save"
20
21      collection := s.db.Database("DevHubDB").Collection("posts")
22      post := &models.Post{
23              User:        userId,
24              Title:       title,
25              Content:     content,
26              CreatedAt:   time.Now(),
27              Likes:       0,
28              Dislikes:    0,
29              HeaderImage: headerImage,
30              Comments:    []primitive.ObjectID{},
31              Tags:        tags,
32      }
33
34      insertResult, err := collection.InsertOne(ctx, post)
35      if err != nil {
36              return primitive.NilObjectID, fmt.Errorf("%s: %w", op, err)
37      }
38
39      oid := insertResult.InsertedID.(primitive.ObjectID)
40
41      return oid, nil
42 }
43
44 // Після рефакторингу
45 data := PostData{
46     UserID:      primitive.NewObjectID(),
47     Title:       "My Post Title",
48     Content:     "Post content goes here...",
49     HeaderImage: "header_image_url",
50     Tags:        []string{"tag1", "tag2"},
51 }
52
53 id, err := storage.Save(context.Background(), data)
54
55 func (s *Storage) Save(ctx context.Context, data PostData) (primitive.ObjectID, error) {
56      const op = "storage.mongodb.Save"
57
58      collection := s.db.Database("DevHubDB").Collection("posts")
59
60      post := &models.Post{
61              User:        data.UserID,
62              Title:       data.Title,
63              Content:     data.Content,
64              CreatedAt:   time.Now(),
65              Likes:       0,
66              Dislikes:    0,
67              HeaderImage: data.HeaderImage,
68              Comments:    []primitive.ObjectID{},
69              Tags:        data.Tags,
70      }
71
72      insertResult, err := collection.InsertOne(ctx, post)
73      if err != nil {
74              return primitive.NilObjectID, fmt.Errorf("%s: %w", op, err)
75      }
76
77      oid := insertResult.InsertedID.(primitive.ObjectID)
78
79      return oid, nil
80 }



ДОДАТОК Г
Код до та після застосування методу «Розкладання умовного оператора»

01 // До рефакторингу
02 if r.FormValue("title") == "" && r.FormValue("content") == "" && (r.FormValue("tags") == "" || r.FormValue("tags") == "[]") {
03      if _, _, err := r.FormFile("headerImage"); err == http.ErrMissingFile {
04              utils.HandleError(log, w, r, "no fields provided for update", nil, http.StatusBadRequest, "body", "At least one field must be provided")
05              return
06      }
07 }
08
09 // Після рефакторингу
10 if isTitleContentAndTagsEmpty(r) && isHeaderImageMissing(r) {
11      utils.HandleError(log, w, r, "no fields provided for update", nil,
12              http.StatusBadRequest, "body", "At least one field must be provided")
13      return
14 }
15
16 func isTitleContentAndTagsEmpty(r *http.Request) bool {
17     return r.FormValue("title") == "" &&
18            r.FormValue("content") == "" &&
19            (r.FormValue("tags") == "" || r.FormValue("tags") == "[]")
20 }
21
22 func isHeaderImageMissing(r *http.Request) bool {
23     _, _, err := r.FormFile("headerImage")
24     return err == http.ErrMissingFile
25 }
ДОДАТОК Д
Скриншоти презентації

 
Рисунок Д.1 – Титульний лист

 
Рисунок Д.2 – Зміст доповіді


Рисунок Д.3 – Вступ. Поняття рефакторингу


Рисунок Д.4 – Опис першого методу рефакторинга


Рисунок Д.5 – Приклад коду до застосування першого методу рефакторинга


Рисунок Д.6 – Приклад коду після застосування першого методу рефакторинга

 
Рисунок Д.7 – Опис другого методу рефакторинга

 
Рисунок Д.8 – Приклад коду до застосування другого методу рефакторинга

 
Рисунок Д.9 – Приклад коду після застосування другого методу рефакторинга

 
Рисунок Д.10 – Опис третього методу рефакторинга
 
Рисунок Д.11 – Приклад коду до застосування третього методу рефакторинга

 
Рисунок Д.12 – Приклад коду після застосування третього методу рефакторинга
 
Рисунок Д.13 – Опис інструментів для рефакторинга коду

 
Рисунок Д.14 – Висновки, щодо застосування рефакторинга коду
 
Рисунок Д.15 – Список використаних джерел

    
